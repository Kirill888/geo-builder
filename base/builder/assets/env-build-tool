#!/bin/bash

set -o errexit
set -o noclobber
set -o pipefail
set -o nounset

CC_GDAL=/opt/constraints-gdal.txt
ENV0=/opt/env0

env_bootstrap_libs="pip setuptools wheel"

# remove comments (#) and empty lines and trailing/leading whitespaces
uncomment () {
    awk '!/^[[:blank:]]*#/ && \
         !/^[[:blank:]]*$/\
    {gsub(/^[[:blank:]]*/, ""); \
    gsub(/[[:blank:]]*$/, "");\
    gsub(/#.*$/, "");\
    print $0}'
}

#
# 1. NOBINARY pointing to a file
# 2. NOBINARY with embedded content
# 3. /conf/nobinary.txt
get_nobinary () {
    if [ -n "${NOBINARY:-}" ]; then
        if [ -f "${NOBINARY}" ]; then
            uncomment < "${NOBINARY}"
        else
            echo "${NOBINARY}" | uncomment
        fi
    else
        if [ -f /conf/nobinary.txt ]; then
            uncomment < /conf/nobinary.txt
        fi
    fi
}

# construct and print --no-binary=lib,lib2, option, or "" if not set
get_nobinary_cmdline () {
    local nobin=$(get_nobinary)
    if [ -n "${nobin}" ]; then
        echo "${nobin}" | awk 'BEGIN {ORS=""; print "--no-binary="; ORS=","}{print $1}'
    fi
}

# download/compile wheels from requirements.txt
#   wheels that are in /wheels will be copied through and not re-compiled
cmd_wheels () {
    local requirements="${1:-/conf/requirements.txt}"
    local constraints="${2:-/conf/constraints.txt}"
    local dst_wheels="${3:-/wheels}"

    local pip="${ENV0}/bin/python -m pip"
    $pip wheel \
        --constraint="${CC_GDAL}" \
        --constraint="${constraints}" \
        --requirement="${requirements}" \
        --wheel-dir="${dst_wheels}"

    local nobinary_libs=$(get_nobinary)
    if [ -n "${nobinary_libs}" ]; then
        echo "Recompiling a set of libs locally"
        for wheel in $(cmd_list-manylinux-wheels "${dst_wheels}" ${nobinary_libs}); do
            echo "Processing: $wheel"
            cmd_pkg-recompile $wheel
            mv "${wheel}" "${wheel}.bk"
        done
    fi
}

# Given path to manylinux wheel build local lib instead
#  1. download source package for this lib from pypi
#  2. compile it to a wheel
cmd_pkg-recompile () {
    local src="$1"
    local dst="${2:-$(dirname $src)}"
    local pip="${ENV0}/bin/python -m pip"

    echo $(basename "${src}") | awk -F - '{print $1, $2}'| (
        read lib version
        echo "Processing ${lib}==$version in ${dst}"
        $pip download -d "${dst}" --no-deps --no-build-isolation --no-binary=$lib $lib==$version

        lib_src=$(find "${dst}" -name "${lib}-${version}"'.*' | head -1)
        echo "Compiling ${lib_src}"
        $pip wheel --no-deps -w "${dst}" "${lib_src}"
    )
}

cmd_list-manylinux-wheels() {
    local wheels="${1}"
    shift
    for lib in $@; do
        find "${wheels}" -iname "${lib}-"'*manylinux*.whl'
    done
}


# Construct environment from /wheels folder only, no downloads
#
cmd_new_no_index () {
    local requirements="${1:-/conf/requirements.txt}"
    local env="${2:-/env}"
    local wheels="${3:-/wheels}"

    mkdir -p "${env}"
    python3 -m venv "${env}"
    local pip="${env}/bin/python -m pip"
    $pip install --upgrade ${env_bootstrap_libs}
    $pip install \
         --constraint="${CC_GDAL}" \
         --find-links="${wheels}" \
         --no-index \
         --requirement="${requirements}"
}


# Construct environment from requirements.txt and constraints.txt
#
cmd_new () {
    local requirements="${1:-/conf/requirements.txt}"
    local constraints="${2:-/conf/constraints.txt}"
    local env="${3:-/env}"

    mkdir -p "${env}"
    python3 -m venv "${env}"
    local pip="${env}/bin/python -m pip"

    $pip install --upgrade $env_bootstrap_libs

    $pip install \
        --constraint="${CC_GDAL}" \
        $(get_nobinary_cmdline) \
        --constraint="${constraints}" \
        --requirement="${requirements}"
}

# Add more libraries to an existing python env
#
cmd_extend () {
    local requirements="${1:-/conf/requirements.txt}"
    local constraints="${2:-/conf/constraints.txt}"
    local env="${3:-/env}"

    local pip="${env}/bin/python -m pip"

    $pip install \
         --constraint="${CC_GDAL}" \
         --constraint="${constraints}" \
         --requirement="${requirements}"
}

cmd_help () {
    echo 'env-build-tool <wheels|new|new_no_index|extend|help> ARGS

Download or compile the required wheels into `wheel_dir`
  > env-build-tool wheels <requirements.txt> <constraints.txt> <wheel_dir:/wheels>

Make a new python environment from the requirements and constraints
  > env-build-tool new <requirements.txt> <constraints.txt> <env:/env>

Extend existing python environment using requirements and constraints
  > env-build-tool extend <requirements.txt> <constraints.txt> <env:/env>

Make a new python environment from the requirements and wheels_dir (No Downloads)
  > env-build-tool new_no_index <requirements.txt <env:/env> <wheel_dir:/wheels>

Recompile manylinux wheel
  > env-build-tool pkg-recompile <path-to-wheel-file> [<dst_dir>]

List manylinux wheels in a folder
  > env-build-tool list-manylinux-wheels
'
}


cmd_main () {
   local cmd="${1:-help}"
   shift || true # Always succeed, so that we display help text on no args

   case "${cmd}" in
       wheels|new|extend|pkg-recompile|new_no_index|list-manylinux-wheels|help)
           "cmd_${cmd}" $@
           ;;
       *)
           echo "ERROR: No such command \"${cmd}\""
           echo
           cmd_help
           exit 1
           ;;
   esac
}

cmd_main $@
